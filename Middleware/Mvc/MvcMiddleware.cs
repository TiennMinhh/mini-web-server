using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using MiniWebServer.Abstractions.Http;
using MiniWebServer.MiniApp;
using MiniWebServer.Mvc.Abstraction;
using MiniWebServer.Mvc.LocalAction;
using System.Xml.Linq;

namespace MiniWebServer.Mvc
{
    public class MvcMiddleware : IMiddleware
    {
        private readonly MvcOptions options;
        private readonly IServiceCollection serviceCollection;
        private readonly ILogger<MvcMiddleware> logger;
        private readonly IActionFinder actionFinder;

        public MvcMiddleware(MvcOptions options, ILoggerFactory loggerFactory, IServiceCollection serviceCollection)
        {
            this.options = options ?? throw new ArgumentNullException(nameof(options));
            this.serviceCollection = serviceCollection ?? throw new ArgumentNullException(nameof(serviceCollection));

            logger = loggerFactory != null ? loggerFactory.CreateLogger<MvcMiddleware>() : NullLogger<MvcMiddleware>.Instance;
            actionFinder = options.ActionFinder;
        }

        public async Task InvokeAsync(IMiniAppContext context, ICallable next, CancellationToken cancellationToken = default)
        {
            try
            {
                var actionInfo = actionFinder.Find(context);
                if (actionInfo != null)
                {
                    // build new local service collection, the new collection will contain services from app's collection and some request specific services
                    var localServiceCollection = new ServiceCollection();
                    foreach (var serv in serviceCollection)
                    {
                        localServiceCollection.Add(serv);
                    }
                    localServiceCollection.AddTransient(services => context);

                    var localServiceProvider = localServiceCollection.BuildServiceProvider();

                    if (ActivatorUtilities.CreateInstance(localServiceProvider, actionInfo.ControllerType) is Controller controller)
                    {
                        // init standard properties
                        controller.ControllerContext = new ControllerContext(context);

                        if (!CallActionMethod(localServiceProvider, controller, actionInfo, context, cancellationToken))
                        {
                            logger.LogError("Error processing action {a}", actionInfo.MethodInfo);
                            context.Response.StatusCode = Abstractions.HttpResponseCodes.InternalServerError;
                        }
                    }
                    else
                    {
                        logger.LogError("Error instantiating controller {c}", actionInfo.ControllerType);
                        context.Response.StatusCode = Abstractions.HttpResponseCodes.InternalServerError;

                        return;
                    }
                }
                else
                {
                    await next.InvokeAsync(context, cancellationToken);
                }
            } catch (Exception ex)
            {
                logger.LogError(ex, "Unhandled error while processing request");
                context.Response.StatusCode = Abstractions.HttpResponseCodes.InternalServerError;

                return;
            }
        }

        private bool CallActionMethod(ServiceProvider localServiceProvider, Controller controller, ActionInfo actionInfo, IMiniAppContext context, CancellationToken cancellationToken)
        {
            /* how do we execute an action?
               - get action parameters
               - foreach parameter:
                  - find a service from localServiceProvider, if found, use it as an action parameter
                  - if not found, find a parameter by name from Request, if found, use it as an action parameter
                  - if not found, return an error (500 Internal Server Error) 
               - execute the action (synchronously or asynchronously)
               - if return value is not an IViewActionResult, call result.ToString() and return a ContentResult
               - otherwise, use ViewEngine to build content using the result as input, return data generated by ViewEngine               
            */

            var actionParameters = actionInfo.MethodInfo.GetParameters();
            var actionParameterValues = new List<object?>(actionParameters.Length);

            foreach (var parameter in actionParameters)
            {
                var parameterName = parameter.Name;
                if (!string.IsNullOrEmpty(parameterName))
                {
                    logger.LogError("Parameter name cannot be empty");
                    return false;
                }

                var parameterType = parameter.ParameterType;
                if (parameterType == null)
                {
                    logger.LogError("Parameter type cannot be null");
                    return false;
                }

                if (TryCreateValue(parameterName, parameterType, localServiceProvider, context, out object? value))
                {
                    actionParameterValues.Add(value);
                }
                else
                {
                    logger.LogError("Cannot bind parameter {p}", parameterName);
                    return false;
                }
            }

            var actionResult = actionInfo.MethodInfo.Invoke(controller, actionParameters.ToArray());
            if (actionResult != null)
            {
                if (actionResult is IViewActionResult)
                {
                    // todo: build result content
                    context.Response.Content = new MiniApp.Content.StringContent("IViewActionResult not implemented: " + actionResult.ToString() ?? string.Empty);
                }
                else
                {
                    context.Response.Content = new MiniApp.Content.StringContent(actionResult.ToString() ?? string.Empty);
                }
            }

            return false;
        }

        private static bool TryCreateValue(string? parameterName, Type parameterType, ServiceProvider localServiceProvider, IMiniAppContext context, out object? value)
        {
            var requestParameter = context.Request.QueryParameters.Where(p => p.Key.Equals(parameterName, StringComparison.InvariantCultureIgnoreCase)).Select(p => p.Value).FirstOrDefault();
            if (requestParameter != null) // a parameter found in Request
            {
                var requestParameterValues = requestParameter.Values.FirstOrDefault(); // currently we support single values only (no array support)

                if (requestParameter != null)
                {
                    if (parameterType == typeof(string))
                    {
                        value = requestParameterValues;
                        return true;
                    }

                    // looking for a public static TryParse method
                    var tryParseMethod = parameterType.GetMethod("TryParse", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
                    if (tryParseMethod != null)
                    {
                        // normally, a TryParse method returns a bool value and accepts 2 parameters: a string and a parsed value
                        var tryParseParameters = new object?[] { requestParameter, null }; // null is place holder of the 2nd parameter (for example: out int? value in int.TryParse)
                        var b = (bool?)tryParseMethod.Invoke(null, tryParseParameters);

                        if (b.HasValue && b.Value)
                        {
                            value = tryParseParameters[1];
                            return true;
                        }
                    }
                    else
                    { 
                        // todo: find a databinder and convert data
                    }
                }
            }

            // if parameter not found, then we try to get a compatible value from DI
            var valueFromDI = localServiceProvider.GetService(parameterType);
            if (valueFromDI != null)
            {
                value = valueFromDI;
                return true;
            }

            value = null;
            return false;
        }
    }
}