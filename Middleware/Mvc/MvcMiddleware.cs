using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using MiniWebServer.MiniApp;
using MiniWebServer.Mvc.Abstraction;
using System.ComponentModel;
using System.Reflection;

namespace MiniWebServer.Mvc
{
    public class MvcMiddleware : IMiddleware
    {
        // https://github.com/daohainam/mini-web-server/issues/6

        private readonly IServiceCollection serviceCollection;
        private readonly ILogger<MvcMiddleware> logger;
        private readonly IActionFinder actionFinder;
        private readonly IViewEngine viewEngine;

        public MvcMiddleware(MvcOptions options, ILoggerFactory loggerFactory, IServiceCollection serviceCollection)
        {
            ArgumentNullException.ThrowIfNull(nameof(options));
            this.serviceCollection = serviceCollection ?? throw new ArgumentNullException(nameof(serviceCollection));

            logger = loggerFactory != null ? loggerFactory.CreateLogger<MvcMiddleware>() : NullLogger<MvcMiddleware>.Instance;
            actionFinder = options.ActionFinder;
            viewEngine = options.ViewEngine;
        }

        public async Task InvokeAsync(IMiniAppContext context, ICallable next, CancellationToken cancellationToken = default)
        {
            try
            {
                var actionInfo = actionFinder.Find(context);
                if (actionInfo != null)
                {
                    // build new local service collection, the new collection will contain services from app's collection and some request specific services
                    var localServiceCollection = new ServiceCollection();
                    foreach (var serv in serviceCollection)
                    {
                        localServiceCollection.Add(serv);
                    }
                    localServiceCollection.AddTransient(services => context);

                    var localServiceProvider = localServiceCollection.BuildServiceProvider();

                    if (ActivatorUtilities.CreateInstance(localServiceProvider, actionInfo.ControllerType) is Controller controller)
                    {
                        // init standard properties
                        controller.ControllerContext = new ControllerContext(context, viewEngine);

                        if (!await CallActionMethodAsync(localServiceProvider, controller, actionInfo, context, cancellationToken))
                        {
                            logger.LogError("Error processing action {a}", actionInfo.MethodInfo);
                            context.Response.StatusCode = Abstractions.HttpResponseCodes.InternalServerError;
                        }
                    }
                    else
                    {
                        logger.LogError("Error instantiating controller {c}", actionInfo.ControllerType);
                        context.Response.StatusCode = Abstractions.HttpResponseCodes.InternalServerError;

                        return;
                    } 
                }
                else
                {
                    await next.InvokeAsync(context, cancellationToken);
                }
            } catch (Exception ex)
            {
                logger.LogError(ex, "Unhandled error while processing request");
                context.Response.StatusCode = Abstractions.HttpResponseCodes.InternalServerError;

                return;
            }
        }

        private async Task<bool> CallActionMethodAsync(ServiceProvider localServiceProvider, Controller controller, ActionInfo actionInfo, IMiniAppContext context, CancellationToken cancellationToken)
        {
            /* how do we execute an action?
               - get action parameters
               - foreach parameter:
                  - find a service from localServiceProvider, if found, use it as an action parameter
                  - if not found, find a parameter by name from Request, if found, use it as an action parameter
                  - if not found, return an error (500 Internal Server Error) 
               - execute the action (synchronously or asynchronously)
               - if return value is not an IViewActionResult, call result.ToString() and return a ContentResult
               - otherwise, use ViewEngine to build content using the result as input, return data generated by ViewEngine               
            */

            var actionParameters = actionInfo.MethodInfo.GetParameters();
            var actionParameterValues = new List<object?>(actionParameters.Length);

            foreach (var parameter in actionParameters)
            {
                var parameterName = parameter.Name;
                if (string.IsNullOrEmpty(parameterName))
                {
                    logger.LogError("Parameter name cannot be empty");
                    return false;
                }

                var parameterType = parameter.ParameterType;
                if (parameterType == null)
                {
                    logger.LogError("Parameter type cannot be null");
                    return false;
                }

                if (TryCreateValue(parameterName, parameterType, localServiceProvider, context, out object? value))
                {
                    actionParameterValues.Add(value);
                }
                else
                {
                    logger.LogError("Cannot bind parameter {p}", parameterName);
                    return false;
                }
            }

            var actionResult = actionInfo.MethodInfo.Invoke(controller, actionParameterValues.ToArray());
            if (actionResult != null)
            {
                if (actionResult is Abstraction.IActionResult ar)
                {
                    var actionContext = new ActionResultContext(controller, actionInfo, context);

                    await ar.ExecuteResultAsync(actionContext);
                }
                else
                {
                    context.Response.Content = new MiniApp.Content.StringContent(actionResult.ToString() ?? string.Empty);
                }

                return true;
            }

            return false;
        }

        private static bool TryCreateValue(string? parameterName, Type parameterType, ServiceProvider localServiceProvider, IMiniAppContext context, out object? value)
        {
            /*
             * How to create an action parameter
             * ---------------------------------
             * Request parameter data type is string, so if action parameter is:
             * - A string: simply use it, else
             * - Try to find a TryParse method (public static bool TryParse(string, out <Action paramtere type?>), if found then use it, else
             * - Try to find a TypeConverter using TypeDescriptor.GetConverter, if found then use it, else
             * - Try to find a model binder (not implemented yet), else
             * - Return false, (then a bad request)
             */

            var requestParameter = context.Request.QueryParameters.Where(p => p.Key.Equals(parameterName, StringComparison.InvariantCultureIgnoreCase)).Select(p => p.Value).FirstOrDefault();
            if (requestParameter != null) // a parameter found in Request
            {
                var requestParameterValue = requestParameter.Values.FirstOrDefault(); // currently we support single values only (no array support)

                if (parameterType == typeof(string)) // no conversion required
                {
                    value = requestParameterValue;
                    return true;
                }

                if (requestParameterValue != null)
                {

                    // looking for a public static bool TryParse method
                    var tryParseMethod = parameterType.GetMethod("TryParse", BindingFlags.Public | BindingFlags.Static, null,
                        new Type[] { typeof(string), parameterType.MakeByRefType() },
                        null);
                    if (tryParseMethod != null && tryParseMethod.ReturnType == typeof(bool))
                    {
                        // normally, a TryParse method returns a bool value and accepts 2 parameters: a string and a parsed value
                        var tryParseParameters = new object?[] { requestParameterValue, null }; // null is place holder of the 2nd parameter (for example: out int? value in int.TryParse)
                        var b = (bool?)tryParseMethod.Invoke(null, tryParseParameters);

                        if (b.HasValue && b.Value)
                        {
                            value = tryParseParameters[1];
                            return true;
                        }
                    }
                    else
                    {
                        var converter = TypeDescriptor.GetConverter(parameterType);
                        if (converter != null) // if we can find a TypeConverter the we use it
                        {
                            if (converter.IsValid(requestParameterValue))
                            {
                                value = converter.ConvertFromString(requestParameterValue);
                                return true;
                            }
                            else
                            {
                                value = null;
                                return false;
                            }
                        }

                        // todo: find a binder and convert data
                    }
                }
            }

            // if parameter not found, then we try to get a compatible value from DI
            var valueFromDI = localServiceProvider.GetService(parameterType);
            if (valueFromDI != null)
            {
                value = valueFromDI;
                return true;
            }

            var underlyingType = Nullable.GetUnderlyingType(parameterType);
            if (underlyingType != null) // this is a nullable type
            {
                value = null;
                return true;
            }

            value = null;
            return false;
        }
    }
}